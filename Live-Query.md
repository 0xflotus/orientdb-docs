Since 2.1

| | |
|----|-----|
|![](images/warning.png)|This feature is experimental and not covered by commercial support, use it at your own risk|


## The concept of Live Query

When executing a SELECT statement (synchronous or asynchronous), you expect the system to return results that are currently present in the database and that match your selection criteria. You expect your result set to be finite and your query to execute in a given time.

A live query acts in a slightly different way:
* it **does not** return data as they are at the moment of the query execution
* it returns **changes** that happen to the database from that moment on and that match your criteria
* it never ends (unless you terminate it or an error occurs)
* it is asynchronous and **push** based: the server will send you data as soon as they are available, you just have to provide a callback.

Just to make the difference explicit, here is a simple example (just the flow of results, not a working example)

**Standard query**

`SELECT FROM PERSON`
```
RID,   NAME,    SURNAME
#12:0, "Jonh",  "Smith"
#12:1, "foo",   "bar"

number of results: 2
```

`INSERT INTO PERSON SET NAME = 'Jenny'`
```
//the SELECT result set is closed, this INSERT operation will not affect it
```


**LIVE query**

`LIVE SELECT FROM PERSON`
```
token: 1234567 // unique identifier of this live query, needed for unsibscription
```
`INSERT INTO PERSON SET NAME = 'Jenny'`
```
//live query listener will receive 'Jenny' record, insert operation
```
`UPDATE PERSON SET NAME = 'Kerry' WHERE NAME = 'Jenny'` 
```
//live query listener will receive 'Kerry' record, update operation
```
`LIVE UNSUBSCRIBE 1234567`
```
//from now on, the live query will not return any other results
```


## Supported interfaces

Live Query is currently supported from the following interfaces
* Java

Following implementations are available in beta version or are waiting for approval
* Node.js (Oriento)

## LiveQuery in Java

To implement LiveQuery in Java you need two elements:
* a statement, to be executed by OLiveQuery
* a listener that asynchronous receives result 

The listener has to implement OLiveResultListener. It just has a callback method that takes the live query token and the record that was modified (with the operation that occurred, eg. insert, update or delete)

```
class MyLiveQueryListener implements OLiveResultListener {

    public List<ORecordOperation> ops = new ArrayList<ORecordOperation>();

    @Override
    public void onLiveResult(int iLiveToken, ORecordOperation iOp) throws OException {
        System.out.println("New result from server for live query "+iLiveToken);
        System.out.println("operation: "+iOp.type);
        System.out.println("content: "+iOp.record);
    }
}
```

To actually execute the live query, you can use the `db.query()` method passing a `OLiveQuery` object as an argument, eg.

```
      ODatabaseDocumentTx db = ... //I suppose you have an active DB instance

      //instantiate the query listener
      MyLiveQueryListener listener = new MyLiveQueryListener();

      //execute the query
      List<ODocument> result = db.query(new OLiveQuery<ODocument>("live select from Test", listener));

      //get the query token, it is needed for unsubscription
      String token = result.get(0).field("token"); // 1234567

      //from now you will receive results from the server for every change that matches your query criteria.

      //if you or someone else executes an INSERT on the server
      db.command(new OCommandSQL("insert into test set name = 'foo', surname = 'bar'")).execute();
      //your MyLiveQueryListener.onLiveResult() will be invoked.
      //in this case the result will be
      //    New result from server for live query 1234567 <- a token generated by the server
      //    operation: 3 <- ORecordOperation.CREATED
      //    content: {@Rid: "#12:0", name: "foo", surname: "bar"}      

      db.command(new OCommandSQL("update test set name = 'baz' where surname = 'bar'")).execute();

      //    New result from server for live query 1234567 
      //    operation: 1 <- ORecordOperation.UPDATED
      //    content: {@Rid: "#12:0", name: "baz", surname: "bar"}      

      db.command(new OCommandSQL("live unsubscribe 1234567")).execute();
      //from now you will not receive any other results

```


